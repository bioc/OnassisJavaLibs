{
    "collab_server" : "",
    "contents" : "package iit.comp.epigen.nlp.similarity;\n\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.commons.io.FilenameUtils;\nimport org.openrdf.model.URI;\n\nimport slib.graph.algo.extraction.validator.dag.ValidatorDAG;\nimport slib.graph.algo.utils.GAction;\nimport slib.graph.algo.utils.GActionType;\nimport slib.graph.algo.utils.GraphActionExecutor;\nimport slib.graph.io.conf.GDataConf;\nimport slib.graph.io.conf.GraphConf;\nimport slib.graph.io.loader.GraphLoaderGeneric;\nimport slib.graph.io.util.GFormat;\nimport slib.graph.model.graph.G;\nimport slib.graph.model.impl.graph.memory.GraphMemory;\nimport slib.graph.model.impl.repo.URIFactoryMemory;\nimport slib.graph.model.repo.URIFactory;\nimport slib.sml.sm.core.engine.SM_Engine;\nimport slib.sml.sm.core.metrics.ic.utils.IC_Conf_Corpus;\nimport slib.sml.sm.core.metrics.ic.utils.IC_Conf_Topo;\nimport slib.sml.sm.core.metrics.ic.utils.ICconf;\nimport slib.sml.sm.core.utils.SMConstants;\nimport slib.sml.sm.core.utils.SMconf;\nimport slib.utils.ex.SLIB_Ex_Critic;\nimport slib.utils.ex.SLIB_Exception;\n\n\npublic class Similarity {\n\t/**\n\t * Class used to compute semantic similarity measures between pairs of concepts\n\t * and group of concepts from a given ontology\n\t *\n\t * @author Eugenia Galeota (eugenia.galeota@iit.it)\n\t *\n\t */\n//\tLogger logger = LoggerFactory.getLogger(this.getClass());\n\n\n\t/**\n\t *\n\t * @param ontologyPath : the path of the ontology file to be loaded (either OBO or RDF_XML)\n\t * @return instance of a graph\n\t * @throws SLIB_Exception\n\t */\n\tpublic G loadOntology(String ontologyPath ) throws SLIB_Exception {\n\t\tGDataConf dataConf;\n\t\tURIFactory factory = URIFactoryMemory.getSingleton();\n\t\tURI graphURI = factory.getURI(\"http://graph/\");\n\t\tG g = new GraphMemory(graphURI);\n\t\tif(\"obo\".equals(FilenameUtils.getExtension(ontologyPath)))\n\t\t\tdataConf = new GDataConf(GFormat.OBO, ontologyPath);\n\t\telse\n\t\t\tdataConf = new GDataConf(GFormat.RDF_XML, ontologyPath);\n\n\t\tGraphConf gConf = new GraphConf();\n\t\tgConf.addGDataConf(dataConf);\n\t\tGraphLoaderGeneric.populate(dataConf, g);\n\n\t\t//Redefining some types of part_of and develops_from to is_a relations\n\n//\t\tlogger.info(\"Changing part_of and develops_from to is_a relations\");\n\t\tGAction predicateSubstitute = new GAction(GActionType.PREDICATE_SUBSTITUTE);\n\n\t\tpredicateSubstitute.addParameter(\"old_uri\", \"http://graph/part_of\");\n\t\tpredicateSubstitute.addParameter(\"new_uri\", \"RDFS.SUBCLASSOF\");\n\t\tGraphActionExecutor.applyAction(predicateSubstitute, g);\n\n\t\tpredicateSubstitute = new GAction(GActionType.PREDICATE_SUBSTITUTE);\n\t\tpredicateSubstitute.addParameter(\"old_uri\", \"http://graph/develops_from\");\n\t\tpredicateSubstitute.addParameter(\"new_uri\", \"RDFS.SUBCLASSOF\");\n\t\tGraphActionExecutor.applyAction(predicateSubstitute, g);\n\n\t\t// Creating a unique root if there is more then one\n\n\t\tSet<URI> roots = new ValidatorDAG().getTaxonomicRoots(g);\n\t\tif(roots.size() > 1){\n\t\t\tGAction actionRerootConf = new GAction(GActionType.REROOTING);\n\t\t\tGraphActionExecutor.applyAction(actionRerootConf, g);\n\t\t}\n\n\n\t//\tlogger.info(g.toString());\n\t\treturn(g);\n\t}\n\n\n\t/* Setting the configuration for pairwise comparisons */\n\t/**\n\t *\n\t * @param pairwiseShortFlag\n\t * @param icConfShortFlag\n\t * @return the configuration to compute pairwise semantic similarity\n\t * @throws SLIB_Ex_Critic\n\t */\n\n\tpublic SMconf setPairwiseConfig(String pairwiseShortFlag, String icConfShortFlag) throws SLIB_Ex_Critic{\n\n\t\tString pairwise = SMConstants.SIM_PAIRWISE_SHORT_FLAG.get(pairwiseShortFlag);\n\t\tSMconf config = new SMconf(pairwise);\n\t\tif(!pairwise.contains(\"_EDGE\")){\n\t\t\tICconf icConf = null;\n\t\t\tif(SMConstants.IC_SHORT_FLAG.get(icConfShortFlag)!=null){\n\t\t\t\tif(!SMConstants.IC_SHORT_FLAG.get(icConfShortFlag).contains(\"_annot\"))\n\t\t\t\t\ticConf = new IC_Conf_Topo(SMConstants.IC_SHORT_FLAG.get(icConfShortFlag));\n\t\t\t\telse\n\t\t\t\t\ticConf = new IC_Conf_Corpus(SMConstants.IC_SHORT_FLAG.get(icConfShortFlag));\n\t\t\t\tconfig.setICconf(icConf);\n\t\t\t}\n\t\t\telse{\n//\t\t\t\tlogger.info(\"Setting IC to default value Resnik. Please run show Options method to view valid IC values\");\n\t\t\t\ticConf = new IC_Conf_Topo(SMConstants.IC_SHORT_FLAG.get(\"resnik\"));\n\t\t\t}\n\t\t}\n\n\t\treturn config;\n\t}\n\n\n\t/**\n\t *\n\t * @param groupwiseShortFlag\n\t * @return the configuration to compute groupwise semantic similarity\n\t * @throws SLIB_Ex_Critic\n\t */\n\n\tpublic SMconf setGroupwiseConfig(String groupwiseShortFlag) throws SLIB_Ex_Critic{\n\t\tString groupwise = SMConstants.SIM_GROUPWISE_SHORT_FLAG.get(groupwiseShortFlag);\n\t\tSMconf config = new SMconf(groupwise);\n\t\treturn config;\n\t}\n\n\n\n\n\tpublic ArrayList<Set<String>> showMeasures() throws SLIB_Ex_Critic{\n\t\tSet<String> pairwise = SMConstants.SIM_PAIRWISE_SHORT_FLAG.keySet();\n\t\tSet<String> infoContent = SMConstants.IC_SHORT_FLAG.keySet();\n\t\tSet<String> groupWiseIt = SMConstants.SIM_GROUPWISE_SHORT_FLAG.keySet();\n\t\tArrayList<Set<String>> optionsList = new ArrayList<Set<String>>();\n\t\toptionsList.add(pairwise);\n\t\toptionsList.add(infoContent);\n\t\toptionsList.add(groupWiseIt);\n\t\treturn optionsList;\n\t}\n\n\n\n\n\n\n\t/**\n\t *\n\t * @return HashMap with all the groupwise configurations\n\t * @throws SLIB_Ex_Critic\n\t */\n\n\n\n\tpublic Map<String, SMconf> getAllGroupwiseMeasures() throws SLIB_Ex_Critic{\n\t\tIterator groupwiseIt = SMConstants.SIM_GROUPWISE_SHORT_FLAG.entrySet().iterator();\n\t\tMap<String, SMconf> configurations = new HashMap<String, SMconf>();\n\t\twhile(groupwiseIt.hasNext()){\n\t\t\tMap.Entry pair = (Map.Entry) groupwiseIt.next();\n\t\t\tSMconf config = new SMconf(pair.getValue().toString());\n\t\t\tconfigurations.put(pair.getKey().toString(), config);\n\t\t}\n\t\treturn configurations;\n\t}\n\n\n\n\t/**\n\t *\n\t * @return Hashmap with all the possible pairwise configurations\n\t * @throws SLIB_Ex_Critic\n\t */\n\n\tpublic Map<String, SMconf> getAllPairwiseCombinations() throws SLIB_Ex_Critic{\n\t\tIterator pairwiseIt = SMConstants.SIM_PAIRWISE_SHORT_FLAG.entrySet().iterator();\n\t\tMap<String, SMconf> configurations = new HashMap<String, SMconf>();\n\t\twhile(pairwiseIt.hasNext()){\n\t\t\tMap.Entry pair = (Map.Entry) pairwiseIt.next();\n\t\t\tSMconf config = new SMconf(pair.getValue().toString());\n\t\t\tif(!pair.getValue().toString().contains(\"_EDGE\")){\n\n\t\t\t\tIterator infoContent = SMConstants.IC_SHORT_FLAG.entrySet().iterator();\n\t\t\t\twhile(infoContent.hasNext()){\n\t\t\t\t\tMap.Entry icPair = (Map.Entry) infoContent.next();\n\t\t\t\t\tICconf icConf = null;\n\t\t\t\t\tString confStringIC = icPair.getValue().toString();\n\n\t\t\t\t\tif(!confStringIC.contains(\"_annot\"))\n\t\t\t\t\t\ticConf = new IC_Conf_Topo(SMConstants.IC_SHORT_FLAG.get(icPair.getKey()));\n\t\t\t\t\telse\n\t\t\t\t\t\ticConf = new IC_Conf_Corpus(SMConstants.IC_SHORT_FLAG.get(icPair.getKey()));\n\t\t\t\t\tif(icConf!=null){\n\t\t\t\t\t\tconfig.setICconf(icConf);\n\t\t\t\t\t\tconfigurations.put(pair.getValue().toString() + \"___________\" + confStringIC, config);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tconfigurations.put(pair.getValue().toString(), config);\n\t\t\t}\n\t\t}\n\t\treturn configurations;\n\t}\n\n\t/** Computation of the groupwise similarity between sets of URIS belonging to a given ontology\n\t *\n\t * @param firstURIset the set of URIs in the first group\n\t * @param secondURIset the set of URIs in the second group\n\t * @param graph the graph object\n\t * @param groupConfig the gropuwise configuration option\n\t * @param pairConfig the pairwise configuration option\n\t * @return\n\t * @throws SLIB_Ex_Critic\n\t */\n\tpublic double group_similarity(Set<URI> firstURIset, Set<URI> secondURIset, G graph, SMconf groupConfig, SMconf pairConfig) throws SLIB_Ex_Critic{\n\n\t\tdouble score = 0;\n\t\tSM_Engine engine;\n\t\tif(groupConfig.getId().equals(SMConstants.FLAG_SIM_GROUPWISE_BMA) ||\n\t\t\t\tgroupConfig.getId().equals(SMConstants.FLAG_SIM_GROUPWISE_MIN) ||\n\t\t\t\tgroupConfig.getId().equals(SMConstants.FLAG_SIM_GROUPWISE_AVERAGE) ||\n\t\t\t\tgroupConfig.getId().equals(SMConstants.FLAG_SIM_GROUPWISE_MAX) ||\n\t\t\t\tgroupConfig.getId().equals(SMConstants.FLAG_SIM_GROUPWISE_BMA) ||\n\t\t\t\tgroupConfig.getId().equals(SMConstants.FLAG_SIM_GROUPWISE_BMM) ){\n\t\t\ttry {\n\t\t\t\tengine = new SM_Engine(graph);\n\t\t\t\tscore = engine.compare(groupConfig, pairConfig, firstURIset, secondURIset);\n\n\t\t\t} catch (Exception e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}else{\n\t\t\ttry {\n\t\t\t\tengine = new SM_Engine(graph);\n\t\t\t\tscore = engine.compare(groupConfig, firstURIset, secondURIset);\n\n\t\t\t} catch (Exception e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\n\t\t}\n\t\treturn score;\n\n\t}\n\n\t/**  Computation of the pairwise similarity between two URIs in a given graph\n\t *\n\t * @param firstURI\n\t * @param secondURI\n\t * @param graph\n\t * @param pairConfig\n\t * @return\n\t * @throws SLIB_Ex_Critic\n\t */\n\tpublic double pair_similarity(URI firstURI, URI secondURI, G graph, SMconf pairConfig) throws SLIB_Ex_Critic{\n\t\tSM_Engine engine;\n\t\tdouble score = 0;\n\t\tengine = new SM_Engine(graph);\n\t\tscore = engine.compare(pairConfig, firstURI, secondURI);\n\t\treturn score;\n\t}\n\n\n\tpublic Map<String, Double> pairWiseCompareAll(URI firstURI, URI secondURI, G graph) throws SLIB_Ex_Critic{\n\t\tMap<String, SMconf> configs = this.getAllPairwiseCombinations();\n\t\tIterator it = configs.entrySet().iterator();\n\t\tMap<String, Double> results = new HashMap<String, Double>();\n\t\twhile(it.hasNext()){\n\t\t\tMap.Entry conf_pair = (Map.Entry) it.next();\n\t\t\tdouble score = pair_similarity(firstURI, secondURI, graph,(SMconf)conf_pair.getValue() );\n\t\t\tresults.put(conf_pair.getKey().toString(), new Double(score));\n\t\t}\n\t\treturn results;\n\t}\n\n\tpublic Map<String, Double> groupWiseCompareAll(Set<URI> firstGroup, Set<URI> secondGroup, G graph) throws SLIB_Ex_Critic{\n\t\tMap<String, SMconf> groupConf = this.getAllGroupwiseMeasures();\n\t\tMap<String, SMconf> pairConf = this.getAllPairwiseCombinations();\n\t\tMap<String, Double> results = new HashMap<String, Double>();\n\n\t\tIterator groupIt = groupConf.entrySet().iterator();\n\t\twhile(groupIt.hasNext()){\n\t\t\tMap.Entry group_conf = (Map.Entry) groupIt.next();\n\t\t\tIterator pairIt = groupConf.entrySet().iterator();\n\t\t\twhile(pairIt.hasNext()){\n\t\t\t\tMap.Entry pair_conf = (Map.Entry) pairIt.next();\n\t\t\t\tdouble score = group_similarity(firstGroup, secondGroup, graph, (SMconf)group_conf.getValue(), (SMconf)pair_conf.getValue());\n\t\t\t\tresults.put(group_conf.getKey().toString() + \"_\" + pair_conf.getKey().toString(), score);\n\t\t\t}\n\t\t}\n\t\treturn results;\n\n\t}\n\n\tpublic Set<URI> createURIs(String [] terms){\n\t\tURIFactory factory = URIFactoryMemory.getSingleton();\n\t\tSet<URI> uriList = new HashSet<URI>();\n\t\tfor(String term: terms){\n\t\t\tURI termURI = factory.getURI(term);\n\t\t\turiList.add(termURI);\n\t\t}\n\t\treturn uriList;\n\t}\n\n\tpublic URI createURI(String term){\n\t\tURIFactory factory = URIFactoryMemory.getSingleton();\n\t\tURI termURI = factory.getURI(term);\n\t\treturn termURI;\n\t}\n\n\tpublic static void main(String [] args){\n\n\t\tSimilarity sim = new Similarity();\n\t\ttry {\n\n\n\t\t\tURIFactory factory = URIFactoryMemory.getSingleton();\n      String filePath = \"BrendaTissue.obo\";\n      ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n      filePath = classLoader.getResource(filePath).getFile();\n \t\t\tG graph = sim.loadOntology(filePath);\n\t\t\tSystem.out.println(graph.toString());\n\t\t\tSystem.out.println(graph.getE().toString());\n\t\t\t//\tSMconf conf = sim.simil(\"topology\", \"resnik\", \"resnik\");\n\t\t\t//\tsim.printMap(SMConstants.pairwiseMeasureMapping);\n\t\t\tSM_Engine engine = new SM_Engine(graph);\n\t\t\tURI bto1 = factory.getURI(\"http://purl.obolibrary.org/obo/BTO_0004732\");\n\t\t\tURI bto2 = factory.getURI(\"http://purl.obolibrary.org/obo/BTO_0000801\");\n\t\t\tURI bto3 = factory.getURI(\"http://purl.obolibrary.org/obo/BTO_0000815\");\n\t\t\tURI bto4 = factory.getURI(\"http://purl.obolibrary.org/obo/BTO_0001912\");\n\t\t\tSet<URI> bto1e2 = new HashSet<URI>();\n\t\t\tbto1e2.add(bto1);\n\t\t\tbto1e2.add(bto2);\n\n\t\t\tSet<URI> bto3e4 = new HashSet<URI>();\n\t\t\tbto3e4.add(bto3);\n\t\t\tbto3e4.add(bto4);\n\n\t\t\tSMconf configMconf = sim.setPairwiseConfig(\"edge_li\", null);\n\t\t\tSystem.out.println(configMconf.toString());\n\t\t\tdouble score = sim.pair_similarity(bto2,bto3, graph, configMconf );\n\t\t\tSMconf group = sim.setGroupwiseConfig(\"bma\");\n\t\t\tdouble score2 = sim.group_similarity(bto1e2, bto3e4,  graph,group,  configMconf);\n\t\t\tSystem.out.println(\"Primo \" + score +\"\\n Secondo \" + score2);\n\t\t} catch (SLIB_Exception e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\n\n}\n\n\n\n",
    "created" : 1495619661702.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "896938879",
    "id" : "EBEE5D66",
    "lastKnownWriteTime" : 1495619707,
    "last_content_update" : 1495619707149,
    "path" : "~/Library/Mobile Documents/com~apple~CloudDocs/IITDrive/OneDriveFondazioneIstitutoItalianoTecnologia/OnassisJavaLibs/java/similarity/src/main/java/iit/comp/epigen/nlp/similarity/Similarity.java",
    "project_path" : "java/similarity/src/main/java/iit/comp/epigen/nlp/similarity/Similarity.java",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "java"
}